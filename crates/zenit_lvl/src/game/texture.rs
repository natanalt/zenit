use crate::node::{LazyData, NodeData};
use std::ffi::CString;
use zenit_proc::{ext_repr, PackedData};

#[derive(Debug, Clone, NodeData)]
pub struct LevelTexture {
    #[node("NAME")]
    pub name: CString,
    /// Due to its dynamic structure and redundant data, it's just defined as a byte buffer.
    ///
    /// Its structure is as follows:
    /// ```c
    /// // blah blah pseudocode
    /// struct TexInfo {
    ///     format_amount: u32,
    ///     formats: [D3DTextureFormat; format_amount],
    /// }
    /// ```
    #[node("INFO")]
    pub info: Vec<u8>,
    #[nodes("FMT_")]
    pub formats: Vec<LevelTextureFormat>,
}

#[derive(Debug, Clone, NodeData)]
pub struct LevelTextureFormat {
    #[node("INFO")]
    pub info: LevelTextureFormatInfo,
    #[nodes("FACE")]
    pub faces: Vec<LevelTextureFace>,

    /// **Zenit-specific extension**
    /// Specifies whether linear texture filtering should be enabled, or not.
    /// Presence of a node means that the texture should be unfiltered.
    #[cfg(feature = "zenit_extensions")]
    #[nodes("NFLT")]
    pub unfiltered: Vec<ZLevelTextureFiltering>,
}

/// A bit sloppy, this is a marker struct for `FMT_:NFLT`
#[derive(Debug, Clone, NodeData)]
pub struct ZLevelTextureFiltering {}

#[derive(Debug, Clone, NodeData)]
pub struct LevelTextureFace {
    #[nodes("LVL_")]
    pub mipmaps: Vec<LevelTextureMipmap>,
}

#[derive(Debug, Clone, NodeData)]
pub struct LevelTextureMipmap {
    #[node("INFO")]
    pub info: LevelTextureMipmapInfo,
    #[node("BODY")]
    pub body: LazyData<Vec<u8>>,
}

#[derive(Debug, Clone, PackedData)]
pub struct LevelTextureMipmapInfo {
    pub mip_level: u32,
    pub body_size: u32,
}

#[derive(Debug, Clone, PackedData)]
pub struct LevelTextureFormatInfo {
    pub format: D3DFormat,
    pub width: u16,
    pub height: u16,
    pub unk_0x08: u16, // i used to call this "depth" for some reason
    pub mipmaps: u16,
    pub kind: LevelTextureKind,
}

/// Direct3D 9 derived texture formats.
///
/// This list only contains the entries that were either commonly generated by
/// the modkit texture munge tools, or entries that were particularly useful
/// for Zenit. The latter is specifically marked as such.
///
/// If any formats are ever to be added here, they must match the `D3DFORMAT`
/// value.
///
/// Reference: https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dformat
#[ext_repr(u32)]
#[derive(
    Debug, Clone, Copy, PartialEq, PackedData, serde::Serialize, serde::Deserialize, clap::ValueEnum,
)]
#[parse_as(u32)]
pub enum D3DFormat {
    /// DXT1/BC1 compressed texture.
    DXT1 = u32::from_le_bytes(*b"DXT1"),
    /// DXT3/BC2 compressed texture.
    DXT3 = u32::from_le_bytes(*b"DXT3"),
    /// 32-bit RGBA, u8 value per channel
    A8R8G8B8 = 0x15,
    /// 16-bit RGB
    R5G6B5 = 0x17,
    /// 16-bit RGB with a single alpha bit
    A1R5G5B5 = 0x19,
    /// 16-bit RGBA
    A4R4G4B4 = 0x1a,
    /// 8-bit alpha only
    A8 = 0x1c,
    /// 8-bit luminance channel only (grayscale)
    L8 = 0x32,
    /// 8-bit alpha + 8-bit luminance
    A8L8 = 0x33,
    /// 4-bit alpha + 4-bit luminance
    A4L4 = 0x34,
    /// 2D signed vector map
    V8U8 = 0x3c,

    /// 24-bit RGB, u8 value per channel.
    ///
    /// This entry was added for Zenit Engine's own purposes, it doesn't seem to be used by
    /// the mainline munge tools.
    R8G8B8 = 0x14,
}

impl D3DFormat {
    pub fn channel_count(self) -> u32 {
        use D3DFormat::*;
        match self {
            DXT1 => 4,
            DXT3 => 4,
            A8R8G8B8 => 4,
            R5G6B5 => 3,
            A1R5G5B5 => 4,
            A4R4G4B4 => 4,
            A8 => 1,
            L8 => 1,
            A8L8 => 2,
            A4L4 => 2,
            V8U8 => 2,
            R8G8B8 => 3,
        }
    }

    pub fn is_compressed(self) -> bool {
        use D3DFormat::*;
        match self {
            DXT1 | DXT3 => true,
            A8R8G8B8 | R5G6B5 | A1R5G5B5 | A4R4G4B4 | A8 | L8 | A8L8 | A4L4 | V8U8 | R8G8B8 => {
                false
            }
        }
    }
}

#[ext_repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, PackedData)]
#[parse_as(u32)]
pub enum LevelTextureKind {
    /// A 2D texture
    D2 = 1,
    /// A 2D cubemap
    Cubemap = 2,
}
